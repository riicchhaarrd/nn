<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Neural Network Curve Approximation using SGD</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>
<body>
<canvas id="canvas" width="600" height="400"></canvas>
<script>
  // A simple neural network with 1 input, 10 hidden nodes, and 1 output.
  function NeuralNetwork(inputNodes, hiddenNodes, outputNodes, learningRate) {
    this.inputNodes = inputNodes;
    this.hiddenNodes = hiddenNodes;
    this.outputNodes = outputNodes;
    this.learningRate = learningRate || 0.1;

    // Initialize weights for input-to-hidden and hidden-to-output layers.
    this.weights_ih = new Array(this.hiddenNodes)
      .fill(0)
      .map(() => new Array(this.inputNodes)
        .fill(0)
        .map(() => Math.random() * 2 - 1));
    this.weights_ho = new Array(this.outputNodes)
      .fill(0)
      .map(() => new Array(this.hiddenNodes)
        .fill(0)
        .map(() => Math.random() * 2 - 1));

    // Biases for hidden and output layers.
    this.bias_h = new Array(this.hiddenNodes)
      .fill(0)
      .map(() => Math.random() * 2 - 1);
    this.bias_o = new Array(this.outputNodes)
      .fill(0)
      .map(() => Math.random() * 2 - 1);

    // Sigmoid activation function and its derivative.
    this.sigmoid = function(x) {
      return 1 / (1 + Math.exp(-x));
    }
    this.dsigmoid = function(y) {
      return y * (1 - y);
    }

    // Feedforward prediction.
    this.predict = function(input_array) {
      // Compute hidden layer outputs.
      let hidden = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.inputNodes; j++) {
          sum += this.weights_ih[i][j] * input_array[j];
        }
        sum += this.bias_h[i];
        hidden[i] = this.sigmoid(sum);
      }
      
      // Compute output layer outputs.
      let output = [];
      for (let i = 0; i < this.outputNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.hiddenNodes; j++) {
          sum += this.weights_ho[i][j] * hidden[j];
        }
        sum += this.bias_o[i];
        output[i] = this.sigmoid(sum);
      }
      return output;
    }

    // Train the network using SGD with one sample per update.
    this.train = function(input_array, target_array) {
      // --- Feedforward ---
      let hidden = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.inputNodes; j++) {
          sum += this.weights_ih[i][j] * input_array[j];
        }
        sum += this.bias_h[i];
        hidden[i] = this.sigmoid(sum);
      }
      
      let outputs = [];
      for (let i = 0; i < this.outputNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.hiddenNodes; j++) {
          sum += this.weights_ho[i][j] * hidden[j];
        }
        sum += this.bias_o[i];
        outputs[i] = this.sigmoid(sum);
      }
      
      // --- Backpropagation ---
      // Calculate output errors.
      let output_errors = [];
      for (let i = 0; i < this.outputNodes; i++) {
        output_errors[i] = target_array[i] - outputs[i];
      }
      
      // Compute gradients for the output layer.
      let gradients = [];
      for (let i = 0; i < this.outputNodes; i++) {
        gradients[i] = this.dsigmoid(outputs[i]) * output_errors[i] * this.learningRate;
      }
      
      // Update weights and biases for hidden-to-output layer.
      for (let i = 0; i < this.outputNodes; i++) {
        for (let j = 0; j < this.hiddenNodes; j++) {
          let delta = gradients[i] * hidden[j];
          this.weights_ho[i][j] += delta;
        }
        this.bias_o[i] += gradients[i];
      }
      
      // Calculate hidden layer errors.
      let hidden_errors = new Array(this.hiddenNodes).fill(0);
      for (let i = 0; i < this.outputNodes; i++) {
        for (let j = 0; j < this.hiddenNodes; j++) {
          hidden_errors[j] += this.weights_ho[i][j] * output_errors[i];
        }
      }
      
      // Compute gradients for the hidden layer.
      let hidden_gradients = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        hidden_gradients[i] = this.dsigmoid(hidden[i]) * hidden_errors[i] * this.learningRate;
      }
      
      // Update weights and biases for input-to-hidden layer.
      for (let i = 0; i < this.hiddenNodes; i++) {
        for (let j = 0; j < this.inputNodes; j++) {
          let delta = hidden_gradients[i] * input_array[j];
          this.weights_ih[i][j] += delta;
        }
        this.bias_h[i] += hidden_gradients[i];
      }
    }
  }

  // Set up the canvas and context.
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Create an instance of the neural network.
  const nn = new NeuralNetwork(1, 10, 1, 0.1);

  // Generate training data for approximating the sine function.
  const trainingData = [];
  for (let i = 0; i < 1000; i++) {
    let x = Math.random() * Math.PI * 2;
    let y = (Math.sin(x) + 1) / 2; // Normalize sine output to [0,1]
    trainingData.push({
      input: [x / (Math.PI * 2)], // Normalize x to [0,1]
      output: [y]
    });
  }

  // Perform one SGD training step by randomly selecting a single training sample.
  function trainStep() {
    const sample = trainingData[Math.floor(Math.random() * trainingData.length)];
    nn.train(sample.input, sample.output);
  }

  // Draw the target sine curve (red) and the neural network's approximation (blue).
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the target sine curve.
    ctx.beginPath();
    ctx.strokeStyle = 'red';
    for (let i = 0; i <= canvas.width; i++) {
      const x = i / canvas.width * Math.PI * 2;
      const y = (Math.sin(x) + 1) / 2;
      const canvasY = canvas.height - y * canvas.height;
      if (i === 0) {
        ctx.moveTo(i, canvasY);
      } else {
        ctx.lineTo(i, canvasY);
      }
    }
    ctx.stroke();

    // Draw the neural network's current approximation.
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    for (let i = 0; i <= canvas.width; i++) {
      const x_norm = i / canvas.width;
      const y_norm = nn.predict([x_norm])[0];
      const canvasY = canvas.height - y_norm * canvas.height;
      if (i === 0) {
        ctx.moveTo(i, canvasY);
      } else {
        ctx.lineTo(i, canvasY);
      }
    }
    ctx.stroke();
  }

  // Main loop: perform multiple SGD training steps and update the drawing.
  function loop() {
    for (let i = 0; i < 10; i++) {
      trainStep();
    }
    draw();
    requestAnimationFrame(loop);
  }

  // Start the training and visualization loop.
  loop();
</script>
</body>
</html>
