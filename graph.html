<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Enhanced Neural Network Curve Approximation with C Export</title>
  <style>
    /* Container for side-by-side layout */
    #container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      margin: 20px;
    }

    /* Left panel for the canvas */
    #left-panel {}

    /* Right panel for stats and export function */
    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }

    #right-panel2 {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Styling for stats and export containers */
    #stats,
    #export-container {
      width: 100%;
      font-family: monospace;
      white-space: pre-wrap;
      background: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      box-sizing: border-box;
    }

    #export-container2 {
      font-family: monospace;
      background: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      box-sizing: border-box;
    }

    #image-upload-container {
      display: none;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ddd;
    }

    #preview-canvas {
      border: 1px solid #ddd;
    }

    #export {
      height: 430px;
      width: 370px;
      font-family: monospace;
      box-sizing: border-box;
    }

    canvas {
      border: 1px solid #333;
      display: block;
    }

    /* Styling for control panel */
    #control-panel {
      margin-top: 10px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ddd;
    }

    #network-controls,
    #function-controls {
      display: grid;
      grid-template-columns: auto auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    /* New dynamic layer options */
    #layer-options {
      margin-top: 10px;
      padding: 10px;
      background: #e8e8e8;
      border: 1px solid #ccc;
      font-family: sans-serif;
    }

    #layer-options div.layer-row {
      margin-bottom: 4px;
    }

    select,
    input,
    label {
      font-family: sans-serif;
    }

    input[type="number"],
    input[type="text"] {
      width: 60px;
    }

    button {
      margin-top: 10px;
      padding: 5px 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #45a049;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="left-panel">
      <canvas id="canvas" width="600" height="400"></canvas>
      <div id="control-panel">
        <div id="network-controls">
          <!-- Hidden vector-dim controls (kept hidden) -->
          <div style="visibility: hidden; display: none;">
            <label for="input-dim">Input Dim:</label>
            <input type="number" id="input-dim" min="1" max="10" value="2">
            <label for="output-dim">Output Dim:</label>
            <input type="number" id="output-dim" min="1" max="10" value="3">
          </div>
          <!-- Learning rate controls -->
          <label for="use-decay">Use Learning Decay:</label>
          <input type="checkbox" id="use-decay" checked>
          <label for="fixed-learning-rate">Fixed LR:</label>
          <input type="number" id="fixed-learning-rate" min="0.0001" max="1" step="0.001" value="0.01">
          <label for="decay-rate">Decay Rate:</label>
          <input type="number" id="decay-rate" min="0.0001" max="1" step="0.0001" value="0.0025">
          <label for="resolution-input">Preview resolution:</label>
          <input type="number" id="resolution-input" min="1" value="64">
          <label for="batch-size">Training Steps/Frame:</label>
          <input type="number" id="batch-size" min="1" max="1000" value="10000">
          <label for="input-activation">Input Activation:</label>
          <select id="input-activation">
            <option value="linear">Linear</option>
            <option value="cos">Cosine</option>
            <option value="tanh">Tanh</option>
            <option value="sigmoid">Sigmoid</option>
            <option value="relu">ReLU</option>
            <option value="leakyRelu">Leaky ReLU</option>
            <option value="swish">Swish</option>
            <option value="smoothstep">Smoothstep</option>
            <option value="sin">Sine</option>
            <option value="gelu">GELU</option>
            <option value="elu">ELU</option>
            <option value="softplus">Softplus</option>
          </select>
          <label for="output-activation">Output Activation:</label>
          <select id="output-activation">
            <option value="linear">Linear</option>
            <option value="cos">Cosine</option>
            <option value="tanh">Tanh</option>
            <option value="sigmoid">Sigmoid</option>
            <option value="relu">ReLU</option>
            <option value="leakyRelu">Leaky ReLU</option>
            <option value="swish">Swish</option>
            <option value="smoothstep">Smoothstep</option>
            <option value="sin">Sine</option>
            <option value="gelu">GELU</option>
            <option value="elu">ELU</option>
            <option value="softplus">Softplus</option>
          </select>
        </div>
        <div id="function-controls">
          <label for="target-function">Target Function:</label>
          <select id="target-function">
            <option value="image">Image</option>
          </select>
          <label for="custom-function" id="custom-function-label" style="display: none;">Custom
            Function:</label>
          <input type="text" id="custom-function" value="Math.sin(x)" style="display: none;">
        </div>
        <!-- Dynamic Layer Options: each hidden layer's configuration -->
        <div id="layer-options">
          <!-- Dynamic rows will be inserted here -->
        </div>
        <div id="layer-options-controls">
          <button id="add-layer">Add Layer</button>
          <button id="remove-layer">Remove Last Layer</button>
        </div>
        <button id="reset-network">Reset Network</button>
        <button id="pause-training">Resume Training</button>
      </div>
      <!-- Image upload container -->
      <div id="image-upload-container">
        <p>Upload an image to train on:</p>
        <input type="file" id="image-upload" accept="image/*">
        <div>
          <label for="image-scale">Image scale:</label>
          <input type="range" id="image-scale" min="0.1" max="1.0" step="0.1" value="1.0">
          <span id="scale-value">1.0</span>
        </div>
        <canvas id="preview-canvas" width="200" height="200"></canvas>
        <button id="use-image">Use This Image</button>
      </div>
    </div>
    <div id="right-panel">
      <div id="stats"></div>
    </div>
    <div id="right-panel2">
      <div id="export-container2">
        <strong>Exported C Function:</strong>
        <div>
          <textarea id="export" readonly></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Helper functions (smoothstep, etc.) ----------
    function mix(a, b, weightb) { return (1 - weightb) * a + weightb * b; }
    function squared(x) { return x * x; }
    function flip(x) { return 1 - x; }
    function smoothstart(t) { return squared(t); }
    function smoothstop(t) { return flip(squared(flip(t))); }
    function smoothstepFunc(x) {
      let t = (x + 4) / 8;
      t = Math.max(0, Math.min(1, t));
      let result = mix(smoothstart(t), smoothstop(t), t);
      return result * 2 - 1;
    }
    function smoothstepPrime(x) {
      let t = (x + 4) / 8;
      if (t <= 0 || t >= 1) return 0;
      let dtResult = 6 * t * (1 - t);
      return dtResult * (1 / 8) * 2;
    }

    const activations = {
      "cos": {
        func: x => Math.cos(x),
        prime: x => -Math.sin(x)
      },
      "tanh": {
        func: x => Math.tanh(x),
        prime: x => 1 - Math.tanh(x) * Math.tanh(x)
      },
      "sigmoid": {
        func: x => 1 / (1 + Math.exp(-x)),
        prime: x => { let s = 1 / (1 + Math.exp(-x)); return s * (1 - s); }
      },
      "relu": {
        func: x => Math.max(0, x),
        prime: x => x > 0 ? 1 : 0
      },
      "leakyRelu": {
        func: x => x > 0 ? x : 0.01 * x,
        prime: x => x > 0 ? 1 : 0.01
      },
      "swish": {
        func: x => x / (1 + Math.exp(-x)),
        prime: x => { let sigm = 1 / (1 + Math.exp(-x)); return sigm + x * sigm * (1 - sigm); }
      },
      "smoothstep": {
        func: smoothstepFunc,
        prime: smoothstepPrime
      },
      "sin": {
        func: x => Math.sin(x),
        prime: x => Math.cos(x)
      },
      "gelu": {
        func: x => 0.5 * x * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3)))),
        prime: x => {
          const k = Math.sqrt(2 / Math.PI);
          const tanhTerm = Math.tanh(k * (x + 0.044715 * Math.pow(x, 3)));
          const sech2 = 1 - tanhTerm * tanhTerm;
          return 0.5 * (1 + tanhTerm) + 0.5 * x * sech2 * k * (1 + 3 * 0.044715 * x * x);
        }
      },
      "elu": {
        func: x => x >= 0 ? x : (Math.exp(x) - 1),
        prime: x => x >= 0 ? 1 : Math.exp(x)
      },
      "softplus": {
        func: x => Math.log(1 + Math.exp(x)),
        prime: x => 1 / (1 + Math.exp(-x))
      },
      "linear": {
        func: x => x,
        prime: x => 1
      }
    };

    // ---------- Image processing ----------
    function processImage(img, scale) {
      const previewCanvas = document.getElementById('preview-canvas');
      const previewCtx = previewCanvas.getContext('2d');
      const scaledWidth = Math.floor(img.width * scale);
      const scaledHeight = Math.floor(img.height * scale);
      previewCanvas.width = scaledWidth;
      previewCanvas.height = scaledHeight;
      previewCtx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
      const imageData = previewCtx.getImageData(0, 0, scaledWidth, scaledHeight);
      const pixels = imageData.data;
      const data = [];
      for (let i = 0; i < pixels.length; i += 4) {
        data.push([(pixels[i] / 128.0) - 1.0, (pixels[i + 1] / 128.0) - 1.0, (pixels[i + 2] / 128.0) - 1.0]);
      }
      return { data: data, width: scaledWidth, height: scaledHeight };
    }
    function getImageValue(x, y) {
      if (!imageData || !imageData.data) return 0;
      const ix = Math.floor(((x - xMin) / (xMax - xMin)) * imageData.width);
      const iy = Math.floor(((y - yMin) / (yMax - yMin)) * imageData.height);
      if (ix < 0 || ix >= imageData.width || iy < 0 || iy >= imageData.height) return 0;
      const index = iy * imageData.width + ix;
      return imageData.data[index] || [0, 0, 0];
    }
    function sampleImagePoint() {
      const x = Math.random() * (xMax - xMin) + xMin;
      const y = Math.random() * (yMax - yMin) + yMin;
      return { x, y, value: getImageValue(x, y) };
    }

    // ---------- Global Variables ----------
    let epoch_ = 0;
    let imageData = null;
    let isTraining = false;
    let batchSize = parseInt(document.getElementById("batch-size").value);
    let currentTargetFunction = "image";

    // Default dynamic layer configuration (array of objects)
    let layerConfigs = [
      // or use sin/cos as default
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" },
      { neurons: 8, norm: "none", dropout: 0.0, activation: "relu" }
    ];

    // ---------- Neural Network Class ----------
    class NeuralNetwork {
      constructor(inputSize, layerConfigs, outputSize, outputActivation = "linear", learningRate) {
        this.inputSize = inputSize;
        this.layerConfigs = layerConfigs; // each object: { neurons, norm, dropout, activation }
        this.hiddenLayerSizes = this.layerConfigs.map(cfg => cfg.neurons);
        this.normModes = this.layerConfigs.map(cfg => cfg.norm);
        this.dropoutRates = this.layerConfigs.map(cfg => cfg.dropout);
        this.hiddenActivations = this.layerConfigs.map(cfg => cfg.activation || "tanh");
        this.inputActivation = "linear";
        this.outputActivation = outputActivation;
        this.numHiddenLayers = this.hiddenLayerSizes.length;
        this.outputSize = outputSize;
        this.learningRate = learningRate;
        this.initializeWeights();
      }
      initializeWeights() {
        epoch_ = 0;
        this.hiddenLayerSizes = this.layerConfigs.map(cfg => cfg.neurons);
        this.normModes = this.layerConfigs.map(cfg => cfg.norm);
        this.dropoutRates = this.layerConfigs.map(cfg => cfg.dropout);
        this.hiddenActivations = this.layerConfigs.map(cfg => cfg.activation || "tanh");
        this.numHiddenLayers = this.hiddenLayerSizes.length;
        this.weights = [];
        this.biases = [];
        this.layerNormGammas = [];
        this.layerNormBetas = [];
        this.ln_means = [];
        this.ln_variances = [];
        this.ln_normalized = [];
        this.bnGammas = [];
        this.bnBetas = [];
        this.bnRunningMeans = [];
        this.bnRunningVariances = [];

        for (let l = 0; l < this.numHiddenLayers; l++) {
          let inDim = (l === 0) ? this.inputSize : this.hiddenLayerSizes[l - 1];
          let layerSize = this.hiddenLayerSizes[l];
          let layerWeights = [];
          let layerBiases = [];
          let limit = Math.sqrt(6 / (inDim + layerSize));
          for (let i = 0; i < layerSize; i++) {
            let neuronWeights = [];
            for (let j = 0; j < inDim; j++) {
              neuronWeights.push(Math.random() * 2 * limit - limit);
            }
            layerWeights.push(neuronWeights);
            layerBiases.push(0);
          }
          this.weights.push(layerWeights);
          this.biases.push(layerBiases);

          if (this.normModes[l] === "layer") {
            let gammas = new Array(layerSize).fill(1);
            let betas = new Array(layerSize).fill(0);
            this.layerNormGammas.push(gammas);
            this.layerNormBetas.push(betas);
            this.ln_means.push(0);
            this.ln_variances.push(1);
            this.ln_normalized.push(new Array(layerSize).fill(0));
            this.bnGammas.push(null); this.bnBetas.push(null);
            this.bnRunningMeans.push(null); this.bnRunningVariances.push(null);
          } else if (this.normModes[l] === "batch") {
            let gammas = new Array(layerSize).fill(1);
            let betas = new Array(layerSize).fill(0);
            let runningMeans = new Array(layerSize).fill(0);
            let runningVars = new Array(layerSize).fill(1);
            this.bnGammas.push(gammas);
            this.bnBetas.push(betas);
            this.bnRunningMeans.push(runningMeans);
            this.bnRunningVariances.push(runningVars);
            this.layerNormGammas.push(null); this.layerNormBetas.push(null);
            this.ln_means.push(null); this.ln_variances.push(null); this.ln_normalized.push(null);
          } else {
            this.layerNormGammas.push(null); this.layerNormBetas.push(null);
            this.ln_means.push(null); this.ln_variances.push(null); this.ln_normalized.push(null);
            this.bnGammas.push(null); this.bnBetas.push(null);
            this.bnRunningMeans.push(null); this.bnRunningVariances.push(null);
          }
        }

        let lastHiddenSize = this.hiddenLayerSizes[this.numHiddenLayers - 1];
        let outputLimit = Math.sqrt(6 / (lastHiddenSize + this.outputSize));
        this.outputWeights = [];
        for (let i = 0; i < this.outputSize; i++) {
          let row = [];
          for (let j = 0; j < lastHiddenSize; j++) {
            row.push(Math.random() * 2 * outputLimit - outputLimit);
          }
          this.outputWeights.push(row);
        }
        this.outputBias = new Array(this.outputSize).fill(0);
      }
      forward(x) {
        let current = x.map(val => activations[this.inputActivation].func(val));
        this.z = [];
        this.h = [];
        for (let l = 0; l < this.numHiddenLayers; l++) {
          let layerSize = this.hiddenLayerSizes[l];
          let zLayer = [];
          for (let i = 0; i < layerSize; i++) {
            let sum = 0;
            for (let j = 0; j < current.length; j++) {
              sum += current[j] * this.weights[l][i][j];
            }
            sum += this.biases[l][i];
            zLayer.push(sum);
          }
          this.z.push(zLayer);
          let hLayer = [];
          let normMode = this.normModes[l];
          if (normMode === "layer") {
            let epsilon = 1e-5;
            let mean = zLayer.reduce((acc, v) => acc + v, 0) / layerSize;
            let variance = zLayer.reduce((acc, v) => acc + (v - mean) ** 2, 0) / layerSize;
            this.ln_means[l] = mean;
            this.ln_variances[l] = variance;
            let normLayer = [];
            for (let i = 0; i < layerSize; i++) {
              let norm = (zLayer[i] - mean) / Math.sqrt(variance + epsilon);
              normLayer.push(norm);
              let preAct = this.layerNormGammas[l][i] * norm + this.layerNormBetas[l][i];
              hLayer.push(activations[this.hiddenActivations[l]].func(preAct));
            }
            this.ln_normalized[l] = normLayer;
          } else if (normMode === "batch") {
            let epsilon = 1e-5, momentum = 0.9;
            let normLayer = [];
            for (let i = 0; i < layerSize; i++) {
              this.bnRunningMeans[l][i] = momentum * this.bnRunningMeans[l][i] + (1 - momentum) * zLayer[i];
              this.bnRunningVariances[l][i] = momentum * this.bnRunningVariances[l][i] + (1 - momentum) * ((zLayer[i] - this.bnRunningMeans[l][i]) ** 2);
              let norm = (zLayer[i] - this.bnRunningMeans[l][i]) / Math.sqrt(this.bnRunningVariances[l][i] + epsilon);
              normLayer.push(norm);
              let preAct = this.bnGammas[l][i] * norm + this.bnBetas[l][i];
              hLayer.push(activations[this.hiddenActivations[l]].func(preAct));
            }
            this.ln_normalized[l] = normLayer;
          } else {
            hLayer = zLayer.map(z => activations[this.hiddenActivations[l]].func(z));
          }
          if (isTraining && this.dropoutRates[l] > 0) {
            let dr = this.dropoutRates[l];
            let mask = [];
            for (let i = 0; i < hLayer.length; i++) {
              mask[i] = (Math.random() < dr) ? 0 : 1 / (1 - dr);
              hLayer[i] *= mask[i];
            }
          }
          this.h.push(hLayer);
          current = hLayer;
        }
        this.zOutput = [];
        for (let i = 0; i < this.outputSize; i++) {
          let sum = this.outputBias[i];
          for (let j = 0; j < current.length; j++) {
            sum += current[j] * this.outputWeights[i][j];
          }
          this.zOutput.push(sum);
        }
        let hOutput = this.zOutput.map(z => activations[this.outputActivation].func(z));
        return hOutput;
      }
      train(x, target, learningRate) {
        let hOutput = this.forward(x);
        let deltaOutput = [];
        for (let i = 0; i < this.outputSize; i++) {
          let error = hOutput[i] - target[i];
          let prime = activations[this.outputActivation].prime(this.zOutput[i]);
          deltaOutput.push(error * prime);
        }
        let lastLayer = this.numHiddenLayers - 1;
        for (let i = 0; i < this.outputSize; i++) {
          for (let j = 0; j < this.hiddenLayerSizes[lastLayer]; j++) {
            let grad = deltaOutput[i] * this.h[lastLayer][j];
            this.outputWeights[i][j] -= learningRate * grad;
          }
          this.outputBias[i] -= learningRate * deltaOutput[i];
        }
        let deltas = [];
        let epsilon = 1e-5;
        let deltaLast = [];
        for (let j = 0; j < this.hiddenLayerSizes[lastLayer]; j++) {
          let sum = 0;
          for (let i = 0; i < this.outputSize; i++) {
            sum += deltaOutput[i] * this.outputWeights[i][j];
          }
          let normMode = this.normModes[lastLayer];
          if (normMode === "layer") {
            let variance = this.ln_variances[lastLayer];
            let norm = this.ln_normalized[lastLayer][j];
            let preAct = this.layerNormGammas[lastLayer][j] * norm + this.layerNormBetas[lastLayer][j];
            let factor = this.layerNormGammas[lastLayer][j] / Math.sqrt(variance + epsilon);
            let delta = sum * factor * activations[this.hiddenActivations[lastLayer]].prime(preAct);
            deltaLast.push(delta);
            this.layerNormGammas[lastLayer][j] -= learningRate * sum * activations[this.hiddenActivations[lastLayer]].prime(preAct) * norm;
            this.layerNormBetas[lastLayer][j] -= learningRate * sum * activations[this.hiddenActivations[lastLayer]].prime(preAct);
          } else if (normMode === "batch") {
            let variance = this.bnRunningVariances[lastLayer][j];
            let norm = this.ln_normalized[lastLayer][j];
            let preAct = this.bnGammas[lastLayer][j] * norm + this.bnBetas[lastLayer][j];
            let factor = this.bnGammas[lastLayer][j] / Math.sqrt(variance + epsilon);
            let delta = sum * factor * activations[this.hiddenActivations[lastLayer]].prime(preAct);
            deltaLast.push(delta);
            this.bnGammas[lastLayer][j] -= learningRate * sum * activations[this.hiddenActivations[lastLayer]].prime(preAct) * norm;
            this.bnBetas[lastLayer][j] -= learningRate * sum * activations[this.hiddenActivations[lastLayer]].prime(preAct);
          } else {
            deltaLast.push(sum * activations[this.hiddenActivations[lastLayer]].prime(this.z[lastLayer][j]));
          }
        }
        deltas[lastLayer] = deltaLast;
        for (let l = this.numHiddenLayers - 2; l >= 0; l--) {
          let deltaNext = deltas[l + 1];
          let deltaCurrent = [];
          for (let i = 0; i < this.hiddenLayerSizes[l]; i++) {
            let sum = 0;
            for (let k = 0; k < this.hiddenLayerSizes[l + 1]; k++) {
              sum += deltaNext[k] * this.weights[l + 1][k][i];
            }
            let normMode = this.normModes[l];
            if (normMode === "layer") {
              let variance = this.ln_variances[l];
              let norm = this.ln_normalized[l][i];
              let preAct = this.layerNormGammas[l][i] * norm + this.layerNormBetas[l][i];
              let factor = this.layerNormGammas[l][i] / Math.sqrt(variance + epsilon);
              let delta = sum * factor * activations[this.hiddenActivations[l]].prime(preAct);
              deltaCurrent.push(delta);
              this.layerNormGammas[l][i] -= learningRate * sum * activations[this.hiddenActivations[l]].prime(preAct) * norm;
              this.layerNormBetas[l][i] -= learningRate * sum * activations[this.hiddenActivations[l]].prime(preAct);
            } else if (normMode === "batch") {
              let variance = this.bnRunningVariances[l][i];
              let norm = this.ln_normalized[l][i];
              let preAct = this.bnGammas[l][i] * norm + this.bnBetas[l][i];
              let factor = this.bnGammas[l][i] / Math.sqrt(variance + epsilon);
              let delta = sum * factor * activations[this.hiddenActivations[l]].prime(preAct);
              deltaCurrent.push(delta);
              this.bnGammas[l][i] -= learningRate * sum * activations[this.hiddenActivations[l]].prime(preAct) * norm;
              this.bnBetas[l][i] -= learningRate * sum * activations[this.hiddenActivations[l]].prime(preAct);
            } else {
              deltaCurrent.push(sum * activations[this.hiddenActivations[l]].prime(this.z[l][i]));
            }
          }
          deltas[l] = deltaCurrent;
        }
        for (let l = 0; l < this.numHiddenLayers; l++) {
          let layerInput = (l === 0) ? x.map(val => activations[this.inputActivation].func(val)) : this.h[l - 1];
          for (let i = 0; i < this.hiddenLayerSizes[l]; i++) {
            for (let j = 0; j < layerInput.length; j++) {
              this.weights[l][i][j] -= learningRate * deltas[l][i] * layerInput[j];
            }
            this.biases[l][i] -= learningRate * deltas[l][i];
          }
        }
      }
    }

    // ---------- Canvas coordinate transforms ----------
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width, height = canvas.height;
    const xMin = -Math.PI, xMax = Math.PI, yMin = -1.5, yMax = 1.5;
    function transformX(x) { return (x - xMin) / (xMax - xMin) * width; }
    function transformY(y) { return height - ((y - yMin) / (yMax - yMin) * height); }

    // ---------- DOM Elements ----------
    const inputDimInput = document.getElementById("input-dim");
    const outputDimInput = document.getElementById("output-dim");
    const batchSizeInput = document.getElementById("batch-size");
    const inputActivationSelect = document.getElementById("input-activation");
    const outputActivationSelect = document.getElementById("output-activation");
    const targetFunctionSelect = document.getElementById("target-function");
    const customFunctionInput = document.getElementById("custom-function");
    const customFunctionLabel = document.getElementById("custom-function-label");
    const resetButton = document.getElementById("reset-network");
    const pauseButton = document.getElementById("pause-training");
    const resolutionInput = document.getElementById("resolution-input");

    // New learning rate controls
    const useDecayInput = document.getElementById("use-decay");
    const fixedLRInput = document.getElementById("fixed-learning-rate");
    const decayRateInput = document.getElementById("decay-rate");

    // Container for dynamic layer options UI
    const layerOptionsDiv = document.getElementById("layer-options");
    const addLayerButton = document.getElementById("add-layer");
    const removeLayerButton = document.getElementById("remove-layer");

    // ---------- Update the dynamic layer options UI ----------
    function updateLayerOptionsUI() {
      layerOptionsDiv.innerHTML = "<strong>Layer Options</strong><br/>";
      const activationOptions = [
        { value: "cos", label: "Cosine" },
        { value: "tanh", label: "Tanh" },
        { value: "sigmoid", label: "Sigmoid" },
        { value: "relu", label: "ReLU" },
        { value: "leakyRelu", label: "Leaky ReLU" },
        { value: "swish", label: "Swish" },
        { value: "smoothstep", label: "Smoothstep" },
        { value: "sin", label: "Sine" },
        { value: "gelu", label: "GELU" },
        { value: "elu", label: "ELU" },
        { value: "softplus", label: "Softplus" },
        { value: "linear", label: "Linear" }
      ];
      layerConfigs.forEach((cfg, index) => {
        let div = document.createElement("div");
        div.className = "layer-row";
        div.innerHTML = `Layer ${index}: Neurons: <input type="number" class="layer-neurons" value="${cfg.neurons}" min="1" style="width:50px;"> 
          Norm: <select class="layer-norm">
            <option value="none" ${cfg.norm === "none" ? "selected" : ""}>None</option>
            <option value="layer" ${cfg.norm === "layer" ? "selected" : ""}>Layer Norm</option>
            <option value="batch" ${cfg.norm === "batch" ? "selected" : ""}>Batch Norm</option>
          </select>
          Dropout: <input type="number" class="layer-dropout" value="${cfg.dropout}" min="0" max="1" step="0.01" style="width:50px;">
          Activation: <select class="layer-activation">
            ${activationOptions.map(opt => `<option value="${opt.value}" ${cfg.activation === opt.value ? "selected" : ""}>${opt.label}</option>`).join('')}
          </select>`;
        layerOptionsDiv.appendChild(div);
      });

      // Event listeners
      document.querySelectorAll(".layer-neurons").forEach((input, i) => {
        input.addEventListener("change", function () {
          layerConfigs[i].neurons = parseInt(this.value) || 1;
          reinitializeNetwork();
        });
      });
      document.querySelectorAll(".layer-norm").forEach((select, i) => {
        select.addEventListener("change", function () {
          layerConfigs[i].norm = this.value;
          reinitializeNetwork();
        });
      });
      document.querySelectorAll(".layer-dropout").forEach((input, i) => {
        input.addEventListener("change", function () {
          layerConfigs[i].dropout = parseFloat(this.value) || 0;
          reinitializeNetwork();
        });
      });
      document.querySelectorAll(".layer-activation").forEach((select, i) => {
        select.addEventListener("change", function () {
          layerConfigs[i].activation = this.value;
          nn.hiddenActivations[i] = this.value;
        });
      });
    }

    // Add/Remove layer buttons
    addLayerButton.addEventListener("click", () => {
      layerConfigs.push({ neurons: 8, norm: "none", dropout: 0.0, activation: "tanh" });
      updateLayerOptionsUI();
      reinitializeNetwork();
    });
    removeLayerButton.addEventListener("click", () => {
      if (layerConfigs.length > 1) {
        layerConfigs.pop();
        updateLayerOptionsUI();
        reinitializeNetwork();
      }
    });

    // ---------- Create and reinitialize network ----------
    function reinitializeNetwork() {
      let inputDim = parseInt(inputDimInput.value);
      let outputDim = parseInt(outputDimInput.value);
      let lr = parseFloat(fixedLRInput.value);
      nn2 = new NeuralNetwork(inputDim, layerConfigs, outputDim, outputActivationSelect.value, lr);
      nn2.inputActivation = inputActivationSelect.value;
      nn = nn2;
    }
    let nn = new NeuralNetwork(parseInt(inputDimInput.value), layerConfigs, parseInt(outputDimInput.value), document.getElementById("output-activation").value, parseFloat(fixedLRInput.value));
    updateLayerOptionsUI();

    // ---------- Training and Drawing Functions ----------
    function trainStep(epoch) {
      if (!isTraining) return false;
      let lr;
      if (useDecayInput.checked) {
        lr = parseFloat(fixedLRInput.value) * Math.exp(-parseFloat(decayRateInput.value) * epoch);
      } else {
        lr = parseFloat(fixedLRInput.value);
      }
      if (lr < 0.00001) return false;
      nn.learningRate = lr;
      let sample = sampleImagePoint();
      let x = [sample.x, sample.y];
      let y = [sample.value[0], sample.value[1], sample.value[2]];
      nn.train(x, y, lr);
      return true;
    }
    function draw() {
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, transformY(0));
      ctx.lineTo(width, transformY(0));
      ctx.moveTo(transformX(0), 0);
      ctx.lineTo(transformX(0), height);
      ctx.stroke();
      if (parseInt(inputDimInput.value) === 1 || currentTargetFunction !== "image") {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        let firstPoint = true;
        for (let i = 0; i <= width; i++) {
          let xVal = xMin + (i / width) * (xMax - xMin);
          let inputVec = [xVal];
          for (let j = 1; j < parseInt(inputDimInput.value); j++) { inputVec.push(0); }
          let outVec = nn.forward(inputVec);
          let cx = transformX(xVal);
          let cy = transformY(outVec[0]);
          if (firstPoint) { ctx.moveTo(cx, cy); firstPoint = false; }
          else { ctx.lineTo(cx, cy); }
        }
        ctx.stroke();
      } else if (parseInt(inputDimInput.value) === 2) {
        const res = parseInt(resolutionInput.value);
        const cellW = width / res, cellH = height / res;
        for (let iy = 0; iy < res; iy++) {
          for (let ix = 0; ix < res; ix++) {
            const xVal = xMin + (ix / res) * (xMax - xMin);
            const yVal = yMin + (iy / res) * (yMax - yMin);
            const output = nn.forward([xVal, yVal]).map(o => Math.max(0, o));
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = `rgba(${output[0] * 255},${output[1] * 255},${output[2] * 255},1)`;
            ctx.fillRect(ix * cellW, iy * cellH, cellW, cellH);
          }
        }
        ctx.globalAlpha = 1.0;
      }
    }
    function updateStats() {
      const statsDiv = document.getElementById("stats");
      let text = "Network Configuration:\n";
      text += `Input Dim: ${nn.inputSize}\n`;
      text += `Input Activation: ${nn.inputActivation}\n`;
      text += `Layer Configs:\n`;
      nn.layerConfigs.forEach((cfg, i) => {
        text += `  Layer ${i}: Neurons=${cfg.neurons}, Norm=${cfg.norm}, Dropout=${cfg.dropout}, Activation=${nn.hiddenActivations[i]}\n`;
      });
      text += `Output Dim: ${nn.outputSize}\n`;
      text += `Output Activation: ${nn.outputActivation}\n`;
      text += `Learning Rate: ${nn.learningRate}\n`;
      nn.weights.forEach((layer, l) => {
        text += `Layer ${l} Weights:\n`;
        layer.forEach((neuron, i) => {
          text += `  Neuron ${i}: ${neuron.map(w => w.toFixed(6)).join(", ")}\n`;
        });
        text += "\n";
      });
      text += "Output Weights:\n";
      nn.outputWeights.forEach((row, i) => {
        text += `  Output Neuron ${i}: ${row.map(w => w.toFixed(6)).join(", ")}\n`;
      });
      text += "\nOutput Biases:\n";
      text += nn.outputBias.map((b, i) => `  Neuron ${i}: ${b.toFixed(6)}`).join("\n");
      statsDiv.textContent = text;
    }
    function updateExport() {
      const exportArea = document.getElementById("export");
      let code = "";
      let scalar = "float";
      let actFuncName = "A";
      function quantize8(w) { return Math.round(((w + 1) / 2) * 255); }
      function serialize_weight(x) { return quantize8(x); }
      let retType = (nn.outputSize === 1) ? scalar : "vec" + nn.outputSize;
      let funcSig = "";
      if (nn.inputSize === 1) { funcSig = retType + " f(" + scalar + " x) {\n"; }
      else { funcSig = retType + " f(vec" + nn.inputSize + " x) {\n"; }
      code += funcSig;
      const comps = [".x", ".y", ".z", ".w"];
      const tempVars = [
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', /*'x',*/ 'y', 'z',
        'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'ag', 'ah', 'ai', 'aj', 'ak', 'al', 'am', 'an', 'ao', 'ap', 'aq', 'ar', 'as', 'at', 'au', 'av', 'aw', 'ax', 'ay', 'az',
        'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bk', 'bl', 'bm', 'bn', 'bo', 'bp', 'bq', 'br', 'bs', 'bt', 'bu', 'bv', 'bw', 'bx', 'by', 'bz',
        'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'cg', 'ch', 'ci', 'cj', 'ck', 'cl', 'cm', 'cn', 'co', 'cp', 'cq', 'cr', 'cs', 'ct', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz',
        'da', 'db', 'dc', 'dd', 'de', 'df', 'dg', 'dh', 'di', 'dj', 'dk', 'dl', 'dm', 'dn', 'do', 'dp', 'dq', 'dr', 'ds', 'dt', 'du', 'dv', 'dw', 'dx', 'dy', 'dz',
        'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'eg', 'eh', 'ei', 'ej', 'ek', 'el', 'em', 'en', 'eo', 'ep', 'eq', 'er', 'es', 'et', 'eu', 'ev', 'ew', 'ex', 'ey', 'ez',
        'fa', 'fb', 'fc', 'fd', 'fe', 'ff', 'fg', 'fh', 'fi', 'fj', 'fk', 'fl', 'fm', 'fn', 'fo', 'fp', 'fq', 'fr', 'fs', 'ft', 'fu', 'fv', 'fw', 'fx', 'fy', 'fz',
        'ga', 'gb', 'gc', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gj', 'gk', 'gl', 'gm', 'gn', 'go', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gv', 'gw', 'gx', 'gy', 'gz',
        'ha', 'hb', 'hc', 'hd', 'he', 'hf', 'hg', 'hh', 'hi', 'hj', 'hk', 'hl', 'hm', 'hn', 'ho', 'hp', 'hq', 'hr', 'hs', 'ht', 'hu', 'hv', 'hw', 'hx', 'hy', 'hz',
        'ia', 'ib', 'ic', 'id', 'ie', 'if', 'ig', 'ih', 'ii', 'ij', 'ik', 'il', 'im', 'in', 'io', 'ip', 'iq', 'ir', 'is', 'it', 'iu', 'iv', 'iw', 'ix', 'iy', 'iz'
      ];
      let tempIndex = 0;
      const hiddenVars = [];
      for (let l = 0; l < nn.numHiddenLayers; l++) {
        hiddenVars[l] = [];
        for (let i = 0; i < nn.hiddenLayerSizes[l]; i++) {
          hiddenVars[l][i] = tempVars[tempIndex++];
        }
      }
      const outputVars = [];
      for (let i = 0; i < nn.outputSize; i++) {
        outputVars[i] = tempVars[tempIndex++];
      }
      for (let l = 0; l < nn.numHiddenLayers; l++) {
        for (let i = 0; i < nn.hiddenLayerSizes[l]; i++) {
          let line = "";
          if (l === 0) {
            if (nn.inputSize === 1) {
              line = "    " + scalar + " " + hiddenVars[l][i] + " = " + actFuncName +
                "( x * Q(" + serialize_weight(nn.weights[0][i][0]) + ") + " + nn.biases[0][i].toFixed(6) + " );\n";
            } else {
              let terms = [];
              for (let j = 0; j < nn.inputSize; j++) {
                terms.push("x" + comps[j] + " * Q(" + serialize_weight(nn.weights[0][i][j]) + ")");
              }
              line = "    " + scalar + " " + hiddenVars[l][i] + " = " + actFuncName +
                "( " + terms.join(" + ") + " + " + nn.biases[0][i].toFixed(6) + " );\n";
            }
          } else {
            let terms = [];
            for (let j = 0; j < nn.hiddenLayerSizes[l - 1]; j++) {
              terms.push(hiddenVars[l - 1][j] + " * Q(" + serialize_weight(nn.weights[l][i][j]) + ")");
            }
            line = "    " + scalar + " " + hiddenVars[l][i] + " = " + actFuncName +
              "( " + terms.join(" + ") + " + " + nn.biases[l][i].toFixed(6) + " );\n";
          }
          code += line;
        }
      }
      for (let i = 0; i < nn.outputSize; i++) {
        let line = "";
        let last = nn.numHiddenLayers - 1;
        let terms = [];
        for (let j = 0; j < nn.hiddenLayerSizes[last]; j++) {
          terms.push(hiddenVars[last][j] + " * Q(" + serialize_weight(nn.outputWeights[i][j]) + ")");
        }
        line = "    " + scalar + " " + outputVars[i] + " = " + nn.outputBias[i].toFixed(6) +
          " + " + terms.join(" + ") + ";\n";
        code += line;
      }
      if (nn.outputSize === 1) { code += "    return " + outputVars[0] + ";\n"; }
      else { code += "    return " + retType + "(" + outputVars.join(", ") + ");\n"; }
      code += "}\n";
      exportArea.value = code;
    }

    // ---------- Event Listeners ----------
    inputActivationSelect.addEventListener("change", function () { nn.inputActivation = this.value; });
    outputActivationSelect.addEventListener("change", function () { nn.outputActivation = this.value; });
    targetFunctionSelect.addEventListener("change", function () {
      currentTargetFunction = this.value;
      if (this.value === "custom") {
        customFunctionInput.style.display = "inline-block";
        customFunctionLabel.style.display = "inline-block";
      } else {
        customFunctionInput.style.display = "none";
        customFunctionLabel.style.display = "none";
      }
    });
    customFunctionInput.addEventListener("change", function () {
      try { new Function('x', 'return ' + this.value)(0); }
      catch (e) { alert("Invalid function expression."); this.value = "Math.sin(x)"; }
    });
    inputDimInput.addEventListener("change", function () {
      let val = parseInt(this.value);
      if (val > 0) { nn.inputSize = val; nn.initializeWeights(); }
      else { this.value = "1"; }
    });
    outputDimInput.addEventListener("change", function () {
      let val = parseInt(this.value);
      if (val > 0) { nn.outputSize = val; nn.initializeWeights(); }
      else { this.value = "1"; }
    });
    batchSizeInput.addEventListener("change", function () {
      let size = parseInt(this.value);
      if (size > 0) { batchSize = size; }
      else { this.value = "100"; batchSize = 100; }
    });
    // Reset network button
    resetButton.addEventListener("click", function () { nn.initializeWeights(); });
    // Pause/Resume training
    pauseButton.addEventListener("click", function () {
      isTraining = !isTraining;
      this.textContent = isTraining ? "Pause Training" : "Resume Training";
    });
    // Image upload handling
    const imageUploadContainer = document.getElementById("image-upload-container");
    const imageUploadInput = document.getElementById("image-upload");
    const imageScaleInput = document.getElementById("image-scale");
    const scaleValueSpan = document.getElementById("scale-value");
    const useImageButton = document.getElementById("use-image");
    imageScaleInput.addEventListener("input", () => {
      scaleValueSpan.textContent = imageScaleInput.value;
      if (imageUploadInput.files && imageUploadInput.files[0]) { processSelectedImage(); }
    });
    imageUploadInput.addEventListener("change", processSelectedImage);
    function processSelectedImage() {
      const file = imageUploadInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        const img = new Image();
        img.onload = function () {
          const scale = parseFloat(imageScaleInput.value);
          const processed = processImage(img, scale);
          window.tempImageData = processed;
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
    useImageButton.addEventListener("click", () => {
      if (window.tempImageData) {
        imageData = window.tempImageData;
        inputDimInput.value = "2";
        nn.inputSize = 2;
        outputDimInput.value = "3";
        nn.outputSize = 3;
        isTraining = true;
        nn.initializeWeights();
      } else { alert("Please upload an image first."); }
    });
    function setTargetFunctionSelect(val) {
      currentTargetFunction = val;
      if (val === "custom") {
        customFunctionInput.style.display = "inline-block";
        customFunctionLabel.style.display = "inline-block";
        imageUploadContainer.style.display = "none";
      } else if (val === "image") {
        customFunctionInput.style.display = "none";
        customFunctionLabel.style.display = "none";
        imageUploadContainer.style.display = "flex";
      } else {
        customFunctionInput.style.display = "none";
        customFunctionLabel.style.display = "none";
        imageUploadContainer.style.display = "none";
      }
    }
    targetFunctionSelect.addEventListener("change", function () { setTargetFunctionSelect(this.value); });

    function animate() {
      for (let i = 0; i < batchSize; i++) {
        if (!trainStep(epoch_)) break;
      }
      draw();
      updateStats();
      updateExport();
      epoch_++;
      requestAnimationFrame(animate);
    }
    animate();
    window.onload = () => { setTargetFunctionSelect("image"); };
  </script>
</body>

</html>