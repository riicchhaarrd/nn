<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>SGD Neural Network Curve Approximation</title>
    <style>
        canvas {
            border: 1px solid #333;
            display: block;
            margin: 20px auto;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        // Neural Network with one hidden layer
        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize, learningRate) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                this.learningRate = learningRate;

                // Initialize weights and biases randomly between -1 and 1
                this.weights1 = new Array(hiddenSize).fill(0).map(() => Math.random() * 2 - 1);
                this.bias1 = new Array(hiddenSize).fill(0).map(() => Math.random() * 2 - 1);
                this.weights2 = new Array(hiddenSize).fill(0).map(() => Math.random() * 2 - 1);
                this.bias2 = Math.random() * 2 - 1;
            }

            // Activation function (tanh) and its derivative
            tanh(x) {
                return Math.tanh(x);
            }

            dtanh(x) {
                // Derivative of tanh: 1 - tanh(x)^2
                return 1 - Math.tanh(x) * Math.tanh(x);
            }

            // Forward pass: Given input x, compute the network output.
            forward(x) {
                this.a = []; // Pre-activation values for hidden neurons
                this.h = []; // Post-activation (tanh) values for hidden neurons
                for (let i = 0; i < this.hiddenSize; i++) {
                    let a = x * this.weights1[i] + this.bias1[i];
                    this.a[i] = a;
                    this.h[i] = this.tanh(a);
                }
                // Output layer: linear combination of hidden outputs plus bias
                let output = this.bias2;
                for (let i = 0; i < this.hiddenSize; i++) {
                    output += this.weights2[i] * this.h[i];
                }
                return output;
            }

            // Single training step using SGD for one sample (x, target)
            train(x, target) {
                // Forward pass
                let output = this.forward(x);
                let error = output - target;  // error (for squared error loss)

                // Backpropagate: update output layer weights and bias
                for (let i = 0; i < this.hiddenSize; i++) {
                    let gradW2 = error * this.h[i];
                    this.weights2[i] -= this.learningRate * gradW2;
                }
                this.bias2 -= this.learningRate * error;

                // Backpropagate into the hidden layer
                for (let i = 0; i < this.hiddenSize; i++) {
                    let deltaHidden = error * this.weights2[i] * this.dtanh(this.a[i]);
                    this.weights1[i] -= this.learningRate * deltaHidden * x;
                    this.bias1[i] -= this.learningRate * deltaHidden;
                }
            }
        }

        // Set up canvas and coordinate transforms
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;

        // Define the domain for x and range for y.
        // Here, we use x ∈ [–π, π] and y ∈ [–1.5, 1.5]
        const xMin = -Math.PI;
        const xMax = Math.PI;
        const yMin = -1.5;
        const yMax = 1.5;

        function transformX(x) {
            return (x - xMin) / (xMax - xMin) * width;
        }

        function transformY(y) {
            // Flip y so that higher y-values appear at the top of the canvas
            return height - ((y - yMin) / (yMax - yMin) * height);
        }

        // Create the neural network (1 input, 10 hidden neurons, 1 output) with learning rate 0.01
        const nn = new NeuralNetwork(1, 10, 1, 0.01);

        // Target function to approximate (sine curve)
        function targetFunction(x) {
            //   return Math.sin(x);
            return x * x * (1 - x);
        }

        // Perform one training step using a random sample from the domain
        function trainStep() {
            let x = Math.random() * (xMax - xMin) + xMin;
            let y = targetFunction(x);
            nn.train(x, y);
        }

        // Draw the true sine function and the neural network's approximation
        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Draw axes
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.beginPath();
            // X-axis
            ctx.moveTo(0, transformY(0));
            ctx.lineTo(width, transformY(0));
            // Y-axis
            ctx.moveTo(transformX(0), 0);
            ctx.lineTo(transformX(0), height);
            ctx.stroke();

            // Draw the true sine curve (blue)
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            ctx.beginPath();
            let firstPoint = true;
            for (let i = 0; i <= width; i++) {
                let xVal = xMin + (i / width) * (xMax - xMin);
                let yVal = targetFunction(xVal);
                let canvasX = transformX(xVal);
                let canvasY = transformY(yVal);
                if (firstPoint) {
                    ctx.moveTo(canvasX, canvasY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();

            // Draw the neural network's approximation (red)
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.beginPath();
            firstPoint = true;
            for (let i = 0; i <= width; i++) {
                let xVal = xMin + (i / width) * (xMax - xMin);
                let yVal = nn.forward(xVal);
                let canvasX = transformX(xVal);
                let canvasY = transformY(yVal);
                if (firstPoint) {
                    ctx.moveTo(canvasX, canvasY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
        }

        // Animation loop: perform multiple training steps per frame and update the drawing
        function animate() {
            // Run several training iterations per frame for faster convergence
            for (let i = 0; i < 100; i++) {
                trainStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Start the animation loop
        animate();
    </script>
</body>

</html>