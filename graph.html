<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Neural Network Curve Approximation</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>
<body>
<canvas id="canvas" width="600" height="400"></canvas>
<script>
  // A simple neural network with 1 input, 10 hidden nodes, and 1 output.
  function NeuralNetwork(inputNodes, hiddenNodes, outputNodes, learningRate) {
    this.inputNodes = inputNodes;
    this.hiddenNodes = hiddenNodes;
    this.outputNodes = outputNodes;
    this.learningRate = learningRate || 0.1;

    // Initialize weights for input-to-hidden and hidden-to-output layers.
    this.weights_ih = new Array(this.hiddenNodes)
      .fill(0)
      .map(() => new Array(this.inputNodes)
        .fill(0)
        .map(() => Math.random() * 2 - 1));
    this.weights_ho = new Array(this.outputNodes)
      .fill(0)
      .map(() => new Array(this.hiddenNodes)
        .fill(0)
        .map(() => Math.random() * 2 - 1));

    // Biases for hidden and output layers.
    this.bias_h = new Array(this.hiddenNodes)
      .fill(0)
      .map(() => Math.random() * 2 - 1);
    this.bias_o = new Array(this.outputNodes)
      .fill(0)
      .map(() => Math.random() * 2 - 1);

    // Sigmoid activation function and its derivative.
    this.sigmoid = function(x) {
      return 1 / (1 + Math.exp(-x));
    }
    this.dsigmoid = function(y) {
      return y * (1 - y);
    }

    // Feedforward prediction.
    this.predict = function(input_array) {
      // Hidden layer computation.
      let hidden = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.inputNodes; j++) {
          sum += this.weights_ih[i][j] * input_array[j];
        }
        sum += this.bias_h[i];
        hidden[i] = this.sigmoid(sum);
      }
      
      // Output layer computation.
      let output = [];
      for (let i = 0; i < this.outputNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.hiddenNodes; j++) {
          sum += this.weights_ho[i][j] * hidden[j];
        }
        sum += this.bias_o[i];
        output[i] = this.sigmoid(sum);
      }
      return output;
    }

    // Training using simple backpropagation.
    this.train = function(input_array, target_array) {
      // Feedforward: compute hidden layer outputs.
      let hidden = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.inputNodes; j++) {
          sum += this.weights_ih[i][j] * input_array[j];
        }
        sum += this.bias_h[i];
        hidden[i] = this.sigmoid(sum);
      }
      
      // Compute output layer outputs.
      let outputs = [];
      for (let i = 0; i < this.outputNodes; i++) {
        let sum = 0;
        for (let j = 0; j < this.hiddenNodes; j++) {
          sum += this.weights_ho[i][j] * hidden[j];
        }
        sum += this.bias_o[i];
        outputs[i] = this.sigmoid(sum);
      }
      
      // Calculate output errors.
      let output_errors = [];
      for (let i = 0; i < this.outputNodes; i++) {
        output_errors[i] = target_array[i] - outputs[i];
      }
      
      // Calculate gradients for the output layer.
      let gradients = [];
      for (let i = 0; i < this.outputNodes; i++) {
        gradients[i] = this.dsigmoid(outputs[i]) * output_errors[i] * this.learningRate;
      }
      
      // Calculate deltas for weights_ho.
      let weight_ho_deltas = [];
      for (let i = 0; i < this.outputNodes; i++) {
        weight_ho_deltas[i] = [];
        for (let j = 0; j < this.hiddenNodes; j++) {
          weight_ho_deltas[i][j] = gradients[i] * hidden[j];
        }
      }
      
      // Update weights and biases for the hidden-to-output layer.
      for (let i = 0; i < this.outputNodes; i++) {
        for (let j = 0; j < this.hiddenNodes; j++) {
          this.weights_ho[i][j] += weight_ho_deltas[i][j];
        }
        this.bias_o[i] += gradients[i];
      }
      
      // Calculate hidden layer errors.
      let hidden_errors = new Array(this.hiddenNodes).fill(0);
      for (let i = 0; i < this.outputNodes; i++) {
        for (let j = 0; j < this.hiddenNodes; j++) {
          hidden_errors[j] += this.weights_ho[i][j] * output_errors[i];
        }
      }
      
      // Calculate gradients for the hidden layer.
      let hidden_gradients = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        hidden_gradients[i] = this.dsigmoid(hidden[i]) * hidden_errors[i] * this.learningRate;
      }
      
      // Calculate deltas for weights_ih.
      let weight_ih_deltas = [];
      for (let i = 0; i < this.hiddenNodes; i++) {
        weight_ih_deltas[i] = [];
        for (let j = 0; j < this.inputNodes; j++) {
          weight_ih_deltas[i][j] = hidden_gradients[i] * input_array[j];
        }
      }
      
      // Update weights and biases for the input-to-hidden layer.
      for (let i = 0; i < this.hiddenNodes; i++) {
        for (let j = 0; j < this.inputNodes; j++) {
          this.weights_ih[i][j] += weight_ih_deltas[i][j];
        }
        this.bias_h[i] += hidden_gradients[i];
      }
    }
  }

  // Set up the canvas and context.
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Create an instance of the neural network.
  // 1 input, 10 hidden nodes, and 1 output node.
  const nn = new NeuralNetwork(1, 10, 1, 0.1);

  // Generate training data to approximate the sine function.
  // The x values are normalized to [0,1] and the sine values (shifted to [0,1]) are the targets.
  const trainingData = [];
  for (let i = 0; i < 1000; i++) {
    let x = Math.random() * Math.PI * 2;
    let y = (Math.sin(x) + 1) / 2; // normalize sine output to [0,1]
    trainingData.push({
      input: [x / (Math.PI * 2)], // normalize x to [0,1]
      output: [y]
    });
  }

  // Train the network on the training data.
  function trainNN() {
    for (let i = 0; i < trainingData.length; i++) {
      nn.train(trainingData[i].input, trainingData[i].output);
    }
  }

  // Draw the target sine curve (in red) and the neural network approximation (in blue).
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the target sine curve.
    ctx.beginPath();
    ctx.strokeStyle = 'red';
    for (let i = 0; i <= canvas.width; i++) {
      let x = i / canvas.width * Math.PI * 2;
      let y = (Math.sin(x) + 1) / 2;
      let canvasY = canvas.height - y * canvas.height;
      if (i === 0) {
        ctx.moveTo(i, canvasY);
      } else {
        ctx.lineTo(i, canvasY);
      }
    }
    ctx.stroke();

    // Draw the neural network's approximation.
    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    for (let i = 0; i <= canvas.width; i++) {
      let x_norm = i / canvas.width;
      let y_norm = nn.predict([x_norm])[0];
      let canvasY = canvas.height - y_norm * canvas.height;
      if (i === 0) {
        ctx.moveTo(i, canvasY);
      } else {
        ctx.lineTo(i, canvasY);
      }
    }
    ctx.stroke();
  }

  // Main loop: repeatedly train and update the drawing.
  function loop() {
    // Train for several iterations per frame.
    for (let i = 0; i < 10; i++) {
      trainNN();
    }
    draw();
    requestAnimationFrame(loop);
  }

  // Start the loop.
  loop();
</script>
</body>
</html>
